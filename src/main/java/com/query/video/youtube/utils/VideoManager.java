package com.query.video.youtube.utils;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.google.api.services.youtube.model.SearchResult;
import com.query.video.youtube.models.SortingOrder;
import com.query.video.youtube.models.WordFrequencyTuple;

public class VideoManager {

	private static final String KIND = "youtube#video";
	private static final String OUTPUT_FILE_NAME = "/part-r-00000";

	/**
	 * Checks that the result is a video
	 * 
	 * @param items
	 *            - video items to be checked
	 * @return the video results
	 */
	public List<SearchResult> checkVideoResults(List<SearchResult> items) {
		List<SearchResult> videoResults = new ArrayList<SearchResult>();
		if (items == null) {
			return videoResults;
		}

		for (SearchResult singleVideo : items) {
			if (singleVideo.getId().getKind().equals(KIND)) {
				videoResults.add(singleVideo);
			}
		}
		return videoResults;
	}
	
	/**
	 * Reads the file output generated by hadoop and creates a sorted list
	 * of {@code WordFrequencyTuple}.
	 * 
	 * @param filePath - path towards the file generated by hadoop
	 * @return list of {@code WordFrequencyTuple}.
	 */
	public List<WordFrequencyTuple> createSortedWordFrequencyTuples(String filePath) {
		List<WordFrequencyTuple> wordFreqTuples = new ArrayList<>();

		try {
			BufferedReader br = new BufferedReader(new FileReader(filePath + OUTPUT_FILE_NAME));
			String line = br.readLine();

			while (line != null) {
				String[] splits = line.split("\t");
				int freq = Integer.parseInt(splits[1]);
				wordFreqTuples.add(new WordFrequencyTuple(splits[0], freq));
				line = br.readLine();
			}
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		Collections.sort(wordFreqTuples, new WordFrequencyTupleComparator(SortingOrder.DESCENDING));
		return wordFreqTuples;
	}

	/**
	 * @param from - list from where discriminatory words are extracted
	 * @param against - list against which the words in {@code from} are compared to
	 * @param numberOfDiscriminatoryWords - number of discriminatory words to find
	 * @param threshold - maximum admitted word frequency difference
	 * @return the list of of {@code WordFrequencyTuple}, i.e., discriminatory words
	 * and their frequency
	 */
	public List<WordFrequencyTuple> getDiscriminatoryWords(List<WordFrequencyTuple> from,
			List<WordFrequencyTuple> against, int numberOfDiscriminatoryWords, int threshold) {

		List<WordFrequencyTuple> result = new ArrayList<>();
		int index = 0;

		while (result.size() < numberOfDiscriminatoryWords) {
			WordFrequencyTuple tupleList1 = from.get(index);
			WordFrequencyTuple tupleList2 = getTupleWithSameWord(tupleList1, against);
			if (null != tupleList2) {
				if (tupleList1.getFrequency() - tupleList2.getFrequency() >= threshold) {
					result.add(tupleList1);
				}
			} else {
				result.add(tupleList1);
			}
			index++;
		}
		return result;
	}

	private WordFrequencyTuple getTupleWithSameWord(WordFrequencyTuple tuple, List<WordFrequencyTuple> list) {
		for (WordFrequencyTuple wordFrequencyTuple : list) {
			if (tuple.getWord().equals(wordFrequencyTuple.getWord())) {
				return wordFrequencyTuple;
			}
		}
		return null;
	}
}
